Top-K算法

许多查询获取在某些属性上已排序的结果，并且对于某特定K值，只需要前K个结果。有时约束K是显式指定的。例如，一些数据库支持 limit K 子句，它导致只返回前K个结果给查询。另一些数据库支持能指定类似限制的可替代方式。在其他情况下，查询可能没有指定这样的限制，但优化器可能允许指定一个暗示，表明尽管查询会产生更多结果，但是只有查询的前K个结果可能被检索。
        当K值较小时，如果一个查询优化计划先产生整个结果集，然后排序并生成前K个结果，这样做效率会非常低下，因为绝大部分计算出来的中间结果都要被舍弃。已经提出了一些技术来优化这类 top-K 查询。一个简单又高效的做法是始终维持前K个值，而将那些超出范围的元组丢弃。基于类似的想法，为应对大数据量的场景，本文在面向列存的基础上提出一种优化。
数据运算背景
对于当下的数据分析系统(OLAP)，在大数据量下为了实现高效处理，通常将关系的每个属性都单独存储。这种方式带来了四大优势：减少I/O，提高CPU缓存性能，提高压缩效率，向量处理。对于top-k，我们也以列存的视角来看数据结构：

添加图片注释，不超过 140 字（可选）
算法高层概念
一般来说，利用经典的堆数据结构，我们可以确保始终保持K个数据
同样，由于在大数据量下(至少GB级别)，为了更高效地进行计算，我们需要充分利用内存，同时
